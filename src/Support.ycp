/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	modules/Support.ycp
 * Package:	Configuration of support
 * Summary:	Support settings, input and output functions
 * Authors:	Michal Zugec <mzugec@novell.com>
 *
 * $Id: Support.ycp 41350 2007-10-10 16:59:00Z dfiser $
 *
 * Representation of the configuration of support.
 * Input and output routines.
 */

{

module "Support";
textdomain "support";

import "Progress";
import "Report";
import "Summary";
import "Message";
import "Map";
import "PackageSystem";
import "Label";

/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
boolean modified = false;

/**
 */
boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
boolean() AbortFunction = Modified;

/**
 * root password for running supportconfig if module run as non-root
 */
global string root_pw = nil;

global string pwd_file = nil;

global boolean CheckRootPw (string pw) {
    if (pwd_file == nil)
	pwd_file = ((string)SCR::Read (.target.tmpdir) + "/pwd_file");
    SCR::Execute (.target.bash, sformat ("test -e %1 || touch %1", pwd_file));
    SCR::Execute (.target.bash, sformat ("chmod 600 %1", pwd_file));
    SCR::Write (.target.string, pwd_file, pw + "\n");
    integer exit = (integer)SCR::Execute (.target.bash, sformat ("cat %1 | su -c 'echo 0'", pwd_file));
    SCR::Write (.target.string, pwd_file, "");
    boolean success = (exit == 0);
    y2milestone ("Root password check: %1", success);
    if (success)
	root_pw = pw;
    return success;
}

global integer WhoAmI() {
    if ((integer)SCR::Read (.target.size, "/usr/bin/id") <= 0)
    {
        y2warning ("/usr/bin/id not existing, supposing to be root");
        return 0;
    }

    map out = (map) SCR::Execute (.target.bash_output, "/usr/bin/id --user");
    list<string> lines = splitstring (out["stdout"]:"", "\n");
    string strid = lines[0]:"";
    integer id = tointeger (strid);
    if (id == nil)
	return 0;
    return id;
}

global boolean AskForRootPwd () {
    while (root_pw == nil) {
	UI::OpenDialog (`VBox (
	    `Label (_("To continue, enter root password")),
	    `Password (`id (`passwd), _("root Password")),
	    `ButtonBox (
		`PushButton (`id(`ok), `opt (`okButton, `default, `key_F10), Label::OKButton()),
		`PushButton (`id(`cancel), `opt (`cancelButton, `key_F9), Label::CancelButton())
	    )
	));
	symbol input = (symbol)UI::UserInput();
	string pw = (string)UI::QueryWidget (`id (`passwd), `Value);
	UI::CloseDialog ();
	if (input == `cancel)
	    return false;
	if (! CheckRootPw (pw))
	    Report::Error (_("Password incorrect"));
    }
    return true;
}

/**
 * Abort function
 * @return boolean return true if abort
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
    {
	return AbortFunction () == true;
    }
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}

/**
 * Mark as modified, for Autoyast.
 */
global void SetModified(boolean value) {
      modified = true;
  }

global boolean ProposalValid() {
    return proposal_valid;
}

global void SetProposalValid(boolean value) {
    proposal_valid = value;
}

/**
 * @return true if module is marked as "write only" (don't start services etc...)
 */
global boolean WriteOnly() {
    return write_only;
}

/**
 * Set write_only flag (for autoinstalation).
 */
global void SetWriteOnly(boolean value) {
    write_only = value;
}


global void SetAbortFunction(boolean() function) {
    AbortFunction = function;
}

// content of /etc/supportconfig.conf
map configuration = $[];

// options parsed from configuration map
global map options = $[];

// command line parameters for support
global boolean use_defaults=false;
global boolean full_listening=false;
global boolean exclude_disk_scan=false;
global boolean search_for_edir=false;
global boolean full_logging=false;
global boolean minimal_logs=false;
global boolean include_slp=false;
global boolean rpm_check=false;
global boolean additional_logs  =false;
global string novell_number="";

global map<string, any> log_files=$[];
//global string created_directory="";

global string browser=nil;

global string GetParameterList(){
 string parameters="";
 if(use_defaults)	parameters=sformat("%1 %2", parameters, "-D");
 if(full_listening)	parameters=sformat("%1 %2", parameters, "-L");
 if(exclude_disk_scan)	parameters=sformat("%1 %2", parameters, "-d");
 if(search_for_edir)	parameters=sformat("%1 %2", parameters, "-e");
 if(full_logging)	parameters=sformat("%1 %2", parameters, "-A");
 if(minimal_logs)	parameters=sformat("%1 %2", parameters, "-m");
 if(include_slp)	parameters=sformat("%1 %2", parameters, "-s");
 if(rpm_check)		parameters=sformat("%1 %2", parameters, "-v");
 if(additional_logs)    parameters=sformat("%1 %2", parameters, "-l");
 if( size(novell_number)>0 )	parameters=sformat("%1 %2 %3", parameters, "-r", novell_number);
 y2milestone("Create parameter list : %1", parameters);
 return parameters;
}

// Settings: Define all variables needed for configuration of support
// TODO FIXME: Define all the variables necessary to hold
// TODO FIXME: the configuration here (with the appropriate
// TODO FIXME: description)
// TODO FIXME: For example:
//   /**
//    * List of the configured cards.
//    */
//   list cards = [];
//
//   /**
//    * Some additional parameter needed for the configuration.
//    */
//   boolean additional_parameter = true;

/**
 * Read all support settings
 * @return true on success
 */
global boolean Read() {

    /* Support read dialog caption */
    string caption = _("Initializing support Configuration");

    configuration = (map)SCR::Read(.etc.supportconfig.all);
    foreach(map<string, any> row, configuration["value"]:[], {
	options[row["name"]:""]=row["value"]:"";
    });
    /* Error message */
    if(false) Report::Error(Message::CannotReadCurrentSettings());

    // read current settings
    if (PackageSystem::Installed("MozillaFirefox")) browser="firefox";
     else if (PackageSystem::Installed("kde4-konqueror")||PackageSystem::Installed("kdebase3")) browser="konqueror";
      else if (PackageSystem::Installed("opera")) browser="opera";
	else y2error("Couldn't find any supported browser installed.");
    /* Error message */
    if(false) Report::Error(Message::CannotReadCurrentSettings());

    if(Abort()) return false;
    log_files=$[ "tmp_dir":(string)SCR::Read(.target.tmpdir) ];
    modified = false;
    return true;
}

/**
 * Write all support settings
 * @return true on success
 */
global boolean Write() {

    /* Support read dialog caption */
    string caption = _("Saving support Configuration");

    // TODO FIXME And set the right number of stages
    integer steps = 2;

    integer sl = 500;
    sleep(sl);

    // TODO FIXME Names of real stages
    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    /* Progress stage 1/2 */
	    _("Write the settings"),
	    /* Progress stage 2/2 */
	    _("Run SuSEconfig")
	], [
	    /* Progress step 1/2 */
	    _("Writing the settings..."),
	    /* Progress step 2/2 */
	    _("Running SuSEconfig..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();
    sleep(sl);

    // run SuSEconfig
    if(Abort()) return false;
    Progress::NextStage ();
    /* Error message */
    if(false) Report::Error (Message::SuSEConfigFailed());
    sleep(sl);

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();
    sleep(sl);

    if(Abort()) return false;
    return true;
}

global boolean WriteConfig(){
 y2milestone("Writing /etc/supportconfig.conf configuration");
    list new_config=[];
    list<string>used_options=[];
    foreach(map<string, any> row, configuration["value"]:[], {
	row["value"] = options[ row["name"]:"" ]:"";
	new_config=add(new_config, row);
	used_options=add(used_options, row["name"]:"");
    });
    foreach(string key, (list<string>)Map::Keys(options), {
     if(!contains(used_options, key)){
      y2milestone("new option (not in old configuration) %1=%2", key, options[key]:"");
	new_config=add(new_config, $[
			 "name"    : key,
			 "value"   : options[key]:"",
			 "comment" : "",
			 "kind"	   : "value",
			 "type"	   : 1
			]);
     }
    });
    configuration["value"]=new_config;
    SCR::Write(.etc.supportconfig.all, configuration);
    y2milestone("Write /etc/supportconfig.conf :%1", SCR::Write(.etc.supportconfig, nil));
 return true;
}

/**
 * Get all support settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
    // TODO FIXME: your code here (fill the above mentioned variables)...
    return true;
}

/**
 * Dump the support settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
    // TODO FIXME: your code here (return the above mentioned variables)...
    return $[];
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary() {
    // TODO FIXME: your code here...
    /* Configuration summary text for autoyast */
    return [ _("Configuration summary..."), [] ];
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global list Overview() {
    // TODO FIXME: your code here...
    return [];
}

/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages() {
    // TODO FIXME: your code here...
    return $[ "install":[], "remove":[] ];
}

/* EOF */
}
